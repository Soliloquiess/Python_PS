import sys
#sys.stdin=open("input.txt", "r")
def DFS(L, P):
    global cnt
    if L==n:    #종착점에 온거
        cnt+=1 #하나 완성
        for j in range(P):  #알파벳 찍어줌
            print(chr(res[j]+64), end='')   #
        print()
    else:   #가지 먼저 뻗음
        for i in range(1, 27):  #for문 돌면서 뻗음    1~26까지 돔
            if code[L]==i:  #L이 처음에 0인데 이 0번과 i가 같은지 보는거
                res[P]=i    #res의 p라는 지점에  그 i를 넣어주고 호출 넘어감.
                DFS(L+1, P+1)   #한자리숫자일떄 +1 P는 인덱스라 무조건 +1
            elif i>=10 and code[L]==i//10 and code[L+1]==i%10:  #두자리 숫자일떄
                # code[L] == i // 10는 10으로 나눈 몫, code[L+1]==i%10는 i의 1의 자리와 같냐
                #code[L]==i//10 이게 10의 자리숫자와 같은지 보는거
                #code[L+1]==i%10 이게 1의 자리 숫자와 같은지 보는거
                res[P]=i    #res에 p라는 지점에 두자리 숫자인 i 넣는거
                DFS(L+2, P+1)   #DFS 넘어감. L+2(두자리 수이므로), p는 인덱스니까 +1
    return cnt;
if __name__=="__main__":
    code=list(map(int, input()))#리스트로 받아서 끊어 받음 2 5 1 1 4
    n=len(code)                 #n이 종착점
    code.insert(n, -1)          #마지막에 -1 넣은 이유?
    #마지막에 -1을 넣어서 참이 안 되도록
    #code[L+1]==i%10: 여기서 L+1부분이 인덱스 에러가 나므로 -1을 넣어서
    res=[0]*(n+3)
    cnt=0
    print(DFS(0, 0))
    print(cnt)

#알파코드 문제를 예시로 들었을 때, res=[]으로 하면 오류가 나더군요.


# res = [0]*n은 n개의 0이 나열된 길이 n의 리스트를 선언하는 것이고 []는 비어있는 리스트를 선언합니다.
#
# len(res)를 해보면 전자는 n이 나올 거고 후자는 0이 나올 겁니다.
#
# 전자에서는 미리 0으로 채워놓고 상황에 따라 그 0을 다른 숫자로 대치시켜 마지막에 0의 개수 혹은 0이 아닌 개수를 판단해서 무언가를 실행할 때 쓸테고, 비어있는 리스트는 상황에 따라 리스트를 채워간 후에 마지막에 그 리스트를 반환한다거나 할 때 사용할 것 같습니다.
#
# 상황에 따라 다르니 그때그때 맞닥들이실 때 조금씩 살펴보셔도 될 것 같습니다.
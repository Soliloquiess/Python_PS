import sys
from collections import deque
#섹션2 에있던 사과나무와 똑같은데 이걸 bfs 로 풀어보자.
#sys.stdin = open("input.txt", "r")
dx = [-1, 0, 1, 0]
dy = [0, 1, 0, -1]
n = int(input())
a = [list(map(int, input().split())) for _ in range(n)]
ch = [[0] * n for _ in range(n)]
sum = 0
Q = deque()
ch[n // 2][n // 2] = 1  #중앙지점.(중앙을 방문했다고
sum += a[n // 2][n // 2]
Q.append((n // 2, n // 2))  #그 부분을 (중앙) 방문했다고 체크함.
L = 0   #레벨 0
while True:
    if L == n // 2: #n이 5라면 L이 2가 되었을 떄, 목표지점으로 옴. L이 2로오면 목표지점온거.
        break
    size = len(Q)   #큐에 쌓인거
    for i in range(size):   #사이즈만큼 돌고
        tmp = Q.popleft()   #하나 나오면 하나 꺼냄
        for j in range(4):  #그럼 거기서 퍼져야됨.(4갈래로 퍼짐
            x = tmp[0] + dx[j]  #
            y = tmp[1] + dy[j]
            if ch[x][y] == 0:   #탐색한 지정이 0일떄만(방문 안 했을떄만) 1이면 방문한데니까
                sum += a[x][y]  #sum은 a의 [x][y]라는 곳을 누적
                ch[x][y] = 1    #ch에 방문했다고 체크
                Q.append((x, y))
    # print(L,size)
    # for x in ch:
    #     print(x)
    L += 1
print(sum)



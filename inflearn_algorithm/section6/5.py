import sys


# sys.stdin=open("input.txt", "r")
def DFS(L, sum, tsum):  # L이 A이란 리스트를 접근하는 인덱스번호(각각의 바둑이 접근하는 인덱스번호)
    # 각 원소를 접근하는 인덱스 번호, 합계, 거쳐간 원소들의 합
    # 판단한것들을 tsum을 만들어서 누적을해주고 전체 바둑이 무게에서 tsum을 뺴준다.
    #tsum  = 판단을 한 합(부분집합에 넣건 넣지않건 판단을 해서 tsun으로 누적)
    #그걸 전체 바둑이 무게에서 뺴준다.
    #전체바둑이무게-tsum = 여기까지 판단한 바둑이 무게를 전체에서 뻄
    #그냥 total-tsum 은 앞으로 판단해야 될 바둑이들 무게(남은 바둑이들의 무게 계산한거).
    #상태트리에서 현재 트리 아래있는 애들
    #sum에 아래에 더 더 할 바둑이 무게 더했는데 result보다 작으면 내려갈 필요 없음(시간 단축)

    global result
    if sum + (total - tsum) < result:  # Cut Edge
        # 전체 무게에서 tsum을 현재까지 적용한 바둑이의 총 합을 전체에서 뺌.
        # (total - tsum) 이게 앞으로 판단해야할 바둑이들의 총 무게임.
        # 이게 현재 내가 답으로 갖고있는 총무게 result보다 작으면(지금까지의 최적의 답.
        # 그럼 이거보다 더 좋은 답이 안 나온다는거(더 밑으로 뻗을 필요가 없음.


        return

    # 무조건 다 부분집합의 합이 되면 안된다.
    if sum > c:  # sum이 c를 넘어가면 커트함. # 무게제한을 넘는 경우 중단
        return
    if L == n:  # 부분집합 하나 완성되는 말단노드(종료지점에 왔다)
        if sum > result:  # result 참조하고 있는거.(sum = 부분집합(내가만든 부분집합의 합)) # 최댓값 입력
            result = sum

    else:  # 2개의 호출 발생
        DFS(L + 1, sum + a[L], tsum + a[L])
        DFS(L + 1, sum, tsum + a[L])
#판단을 핟 합(부분집합에 넣건 넣지 않건) 판단하면 무조건 tsum에 누적
#거기서 tsum을 뺴줌. (바둑이 총합에서 뺸거. 앞으로 적용해야할 무게들 뺸거)

if __name__ == "__main__":
    c, n = map(int, input().split())
    a = [0] * n# 바둑이 각각의 무게를 받을 리스트
    result = -2147000000# 가능한 바둑이 총 무게의 최댓값
    for i in range(n):
        a[i] = int(input())
    total = sum(a)
    DFS(0, 0, 0)
    print(result)


# 부분집합 사용하기
# 트럭에 태우는 경우
# 부분집합의 총합이 주어진 무게를 넘지 않는 선에서의 최댓값을 구한다.
# 시간복잡도를 단축시킬 수 있는 방법을 사용 (Cut Edge Tech)
# 별도의 변수(a)에 재귀함수로 지나간 원소의 값을 무조건 누적
# 그 값(a)으로 전체 바둑이의 무게의 합을 뺀다.-(b)
# (b)를 부분집합의 합에 더하기 - (c)
# 즉, 해당 부분집합의 시점에서, 앞으로 남은 노드들의 합을 더하는 것
# 이때, 그 시점의 최댓값보다 (c)가 작다면, 중단한다.
# 참조 : https://greedysiru.tistory.com/198

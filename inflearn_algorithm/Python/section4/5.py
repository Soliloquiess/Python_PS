import sys
#sys.stdin=open("input.txt", "r")
#그리디는 문제를 풀어나가는 과정에 있어서 이 단계에서(현재) 제일 좋은 것을 선택
#단계에서 가장 좋은걸 어케 판별하나? 그리드는 거의 대부분이 정렬.
#정렬후 차례차례 선택해 나가면 그리디 문제가 되는 것.
#거의 대부분이 정렬과 동반해서 문제풀이가 된다.

n=int(input()) #정수 하나 받음.
meeting=[]  #빈 리스트 만들어서 여기 저장할 거.
for i in range(n):
    s, e=map(int, input().split())
    meeting.append((s, e))  #리스트에 튜플형태로 넣음. 근데 리스트에 넣어도 됨
                            #선생님은 튜플이 편하다해서 저렇게 넣었다는데, 리스트 넣어도 가능
    #meeting.append([s, e])
meeting.sort(key=lambda x : (x[1], x[0])) #정렬하는 기준
#기준을 끝나는 시간x[1]. 즉 e에 의해서 정렬하면. 끝나는 시간으로 정렬

#meeting.sort(); 만 쓰면 앞에 자료에 의해서만 정렬.  앞에 자료값이 같으면 뒤에 값에 의해 정렬
#이렇게 쓰면 시작시간으로 정렬.

#람다 사용하셨다..
#key=lambda x : (x[1], x[0]) x인수로 받음
#meeting이라는 자료형 하나 받음.
#x[1]번이 우선순위 x[0]번이 차순위. a에 0번, b에 1번 들어감.(바꿔넣음)
#즉 x[1]이 첫순위, x[0]이 끝순위가 되게 함.(정렬 순위에 있어서)
#이 순위에 의해서 정렬하고 끝나는 시간이 같다면 시작시간이 작은 애를 함.(오름차순이니까)
#meeting.sort(); 만 쓰면 앞에 자료에 의해서만 정렬.  앞에 자료값이 같으면 뒤에 값에 의해 정렬


#위에서 정렬 다했으니 출력
et=0    #회의를 했던 그 회의의 끝나는 시간(end time)
cnt=0   #개수)
for s, e in meeting:    #s,e는 시작시간과 끝나는 시간
    #s가 et보다 크면 회의 가능해지는거
    if s>=et:   #시작시간이 끝나는 시간보다 크거나 같으면
        et=e    #엔드타임은 그 시간의 끝나는 시간 넣어줌.
        cnt+=1  #그리고 카운트+1
print(cnt)